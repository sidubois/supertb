""" 
Python Class dedicated to parse the files generated by Elk
"""

import os
import sys
import time
import numpy as np
import math
import warnings
import os.path

from supertb import Structure, Spinor, Eigenset

################################################################################  

class Elkrun(object):

    bohr2angstrom = 0.529177249
    hartree2ev = 27.211396132

    def __init__(self, fileroot="./", **kwargs):

        self.fileroot = fileroot

        # Parse the elk.in file
        self.set_params(**kwargs)

        # Parse the GEOMETRY file
        self.set_geometry(**kwargs)

        # Get Fermi energy
        self.set_efermi(**kwargs)

        # Parse the EIGVAL file
        self.set_eigenvalues(**kwargs)

        # Parse the BAND files
        self.set_bands(**kwargs)
            
        # Parse the projected BAND files
        self.set_projected_bands(**kwargs)
            
    def set_geometry(self, **kwargs):
       
        geom_file = self.fileroot+'GEOMETRY.OUT'

        if 'structure' in kwargs:
            self.structure = kwargs['structure'] 
        elif os.path.isfile(geom_file):
            self.structure = get_geometry_from_file(geom_file)
        else:
            ioerr = 'No parameters found to set up the geometry'
            raise IOError(ioerr)

    def set_params(self, **kwargs):

        input_file = self.fileroot+'elk.in'

        if os.path.isfile(input_file):
            self.params = get_params_from_file(input_file)
            self.spin = Spinor(**self.params) 
            self.has_bands = self.params['has_bands']
            self.has_projected_bands = self.params['has_projected_bands']
        else:
            self.spin = Spinor()
            self.has_bands = False
            self.has_projected_bands = False

        if 'has_bands' in kwargs:
            self.has_bands = kwargs['has_bands']

        if 'has_projected_bands' in kwargs:
            self.has_projected_bands = kwargs['has_projected_bands']


    def set_efermi(self, **kwargs):

        efermi_file = self.fileroot+'EFERMI.OUT'

        if 'efermi' in kwargs:
            self.efermi = kwargs['efermi']
        elif os.path.isfile(efermi_file):
            self.efermi = get_efermi_from_file(efermi_file)
        else:
            self.efermi = 0.

    def set_eigenvalues(self,**kwargs):

        kpts, wkpts = self.read_kpoints(**kwargs)
        ener = self.read_eigenvalues(**kwargs)-self.efermi
        self.eigenvalues = Eigenset(self.structure.lattice, spin=self.spin, \
                         kpts=kpts, wkpts=wkpts, fractional=True)

        self.eigenvalues.set_eigenvalues(E=ener)


    def set_pw_coeffs(self,**kwargs):

        wfpwc = self.read_pw_coeffs()
        for ik in wfpwc:
            for ib in wfpwc[ik]:
                self.eigenvalues[ik][ib][0]['V'] = wfpwc[ik][ib]

    def read_pw_coeffs(self,**kwargs):

        wfpw_file = self.fileroot+'WFPW_FORM.OUT'
        return get_wfpwc_from_file(wfpw_file) 

    def set_pw_spins(self,**kwargs):

        wfspins = self.read_pw_spins()
        for ik in wfspins:
            for ib in wfspins[ik]:
                self.eigenvalues[ik][ib][0]['S'] = wfspins[ik][ib]

    def read_pw_spins(self,**kwargs):
        wfspin_file = self.fileroot+'WFPW_SPIN_FORM.OUT'
        return get_wfspin_from_file(wfspin_file)

    def read_eigenvalues(self,**kwargs):

        eigval_file = self.fileroot+'EIGVAL.OUT'
        ener = get_eigenvalues_from_file(eigval_file)

        return ener
    
    def read_kpoints(self,**kwargs):
        
        kpts_file = self.fileroot+'KPOINTS.OUT'

        if 'kpts' in kwargs:
            kpts = kwargs['kpts']
            if 'wkpts' in kwargs:
                wkpts = kwargs['wkpts']
            else:
                wkpts = np.array([1.]*len(kpts))/len(kpts)

        elif os.path.isfile(kpts_file):
            kpts, wkpts = get_kpoints_from_file(kpts_file)

        return kpts, wkpts

    def set_bands(self,**kwargs):

        if self.has_bands:

            if 'bands_kpts' in kwargs:
                bands_kpts = kwargs['bands_kpts']
            elif self.params['plot1d']['npts'] > 0:
                npts = self.params['plot1d']['npts']
                vcs = self.params['plot1d']['vcs']
                bands_path = [vcs[0]]
                for ivec in range(1,len(vcs)-1):
                    bands_path.append(vcs[ivec])
                    bands_path.append(vcs[ivec])
                bands_path.append(vcs[-1])
                self.bands_path = np.array(bands_path)
                bands_kpts, bands_vertices = \
                    plotpt1d(self.structure, npts, vcs)    

            if 'bands' in kwargs:
                bands_ener = kwargs['bands']
            else:
                bands_file = self.fileroot+'BAND.OUT'    
                if os.path.isfile(bands_file):
                    ener = get_bands_from_file(bands_file)
                else:
                    bands_file = self.fileroot+'BAND_S01_A0001.OUT'
                    if os.path.isfile(bands_file):
                        ener = get_bands_from_file(bands_file)

                nbands, nkpts = ener.shape
                nbands = int(nbands/self.spin.nspin)
                bands_ener = np.transpose(ener.reshape((self.spin.nspin,nbands,nkpts)),(2,1,0))

            #bands_wkpts = np.array([1.]*len(bands_kpts))/len(bands_kpts)
            bands_wkpts = np.array([1.]*len(bands_kpts))
            self.bands_structure = Eigenset(self.structure.lattice, spin=self.spin, \
                                   kpts=bands_kpts, wkpts=bands_wkpts, fractional=True, vertices=bands_vertices)
 
            self.bands_structure.set_eigenvalues(E=bands_ener)

    def set_projected_bands(self,**kwargs):
        
        if self.has_projected_bands:

            if 'projected_bands' in kwargs:
                bands_projs = kwargs['bands_projs']

            else:
                natoms = self.structure.num_sites
                first = True
                for iat in range(natoms): 
                    for ispin in range(self.spin.nspin):
                        bands_file = self.fileroot+'BAND_S'+str(ispin+1).zfill(2)+\
                                     '_A'+str(iat+1).zfill(4)+'.OUT'
                        if os.path.isfile(bands_file):
                            projs = get_projected_bands_from_file(bands_file)
                            #print 'Projected band file :', bands_file
                            #print projs.shape
                 
                        if first:
                            nbands, nkpts, nprojs = projs.shape
                            bands_projs = np.zeros((nkpts,nbands,self.spin.nspin,natoms,nprojs))
                 
                        bands_projs[:,:,ispin,iat,:] = projs.transpose((1,0,2))
                        first = False

            #print bands_projs[0,0,0,:,:]
            self.bands_structure.set_eigenvalues(P=bands_projs)      


################################################################################  


def get_geometry_from_file(geom_file):

    # Parse the GEOMETRY file
    try:
       f = open(geom_file,'r')
    except:
       error_msg = 'File '+geom_file+' not found!'
       raise IOError(error_msg)

    lines = f.readlines()
    for iline, line in enumerate(lines):
        line = line.strip()
        if line == 'scale':
            scale = float(lines[iline+1].strip().split()[0])*Elkrun.bohr2angstrom

        if line == 'avec':
            lattice = np.zeros((3,3))
            lattice[0,:] = [float(x)*scale for x in lines[iline+1].strip().split()[0:3]]
            lattice[1,:] = [float(x)*scale for x in lines[iline+2].strip().split()[0:3]] 
            lattice[2,:] = [float(x)*scale for x in lines[iline+3].strip().split()[0:3]]

        if line == 'atoms':
            nspec = int(lines[iline+1].strip().split()[0])
            ptr = 2
            species = []
            coords = []
            for ispec in range(nspec):
                cspec = lines[iline+ptr].strip().split()[0][1:-4]
                nat = int(lines[iline+ptr+1].strip().split()[0])
                for iat in range(nat):
                    coords.append([float(x)%1. for x in lines[iline+ptr+2+iat].strip().split()[0:3]])
                    species.append(cspec)
                ptr += 2+nat

    f.close()

    structure = Structure(lattice,species,coords) 

    return structure


def get_efermi_from_file(efermi_file):

    # Parse the EFERMI file
    try:
       f = open(efermi_file,'r')

    except:
       error_msg = 'File '+efermi_file+' not found!'
       raise IOError(error_msg)

    efermi = float(f.readline().strip().split()[0])*Elkrun.hartree2ev
    f.close() 
    return efermi



def get_kpoints_from_file(kpts_file):

    # Parse the KPOINTS file
    try:
       f = open(kpts_file,'r')
    except:
       error_msg = 'File '+kpts_file+' not found!'
       raise IOError(error_msg)

    lines = f.readlines()
    nkpts = int(lines[0].strip().split()[0])
    kpts = np.zeros((nkpts,3))
    wkpts = np.zeros((nkpts))
    for ikpt in range(nkpts):
        kpts[ikpt,:] = [float(x) for x in lines[ikpt+1].strip().split()[1:4]]
        wkpts[ikpt] = float(lines[ikpt+1].strip().split()[4])

    f.close()
       
    return kpts, wkpts
         

def get_eigenvalues_from_file(eigval_file):

    # Parse the EIGVAL file
    try:
       f = open(eigval_file,'r')
    except:
       error_msg = 'File '+eigval_file+' not found!'
       raise IOError(error_msg)

    nkpts = int(f.readline().strip().split()[0])
    nbands = int(f.readline().strip().split()[0])

    ener = np.zeros((nkpts,nbands))

    for ikpt in range(nkpts):
        f.readline()
        kpt = f.readline().strip().split()[1:4]
        f.readline()
        for iband in range(nbands): 
            line =  f.readline()
            ener[ikpt,iband] = float(line.strip().split()[1])*Elkrun.hartree2ev
        f.readline()

    f.close() 

    if ener[0,int(nbands/2)] < ener[0,int(nbands/2)-1]:
        return np.reshape(ener,(nkpts,int(nbands/2),2))
    else:
        return np.reshape(ener,(nkpts,nbands,1))



def get_params_from_file(input_file):

    # Parse the elk.in file
    try:
       f = open(input_file,'r')
    except:
       error_msg = 'File '+input_file+' not found!'
       raise IOError(error_msg)

    params = {}
    params['has_bands'] = False
    params['has_projected_bands'] = False
    params['has_spin_bands'] = False
    params['spinpol'] = False
    params['spinorb'] = False
    params['plot1d'] = {}
    params['plot1d']['nvcs'] = 0
    params['plot1d']['npts'] = 0
    params['plot1d']['vcs'] = []

    lines =  f.readlines()
    for iline, line in enumerate(lines): 
        line = line.strip()
        if line == 'tasks':
            for jl in range(200):
                if lines[iline+1+jl].strip() == '':
                    break 
                elif lines[iline+1+jl].strip().split()[0] == '20':
                    params['has_bands'] = True
                elif lines[iline+1+jl].strip().split()[0] == '21':
                    params['has_bands'] = True
                    params['has_projected_bands'] = True
                elif lines[iline+1+jl].strip().split()[0] == '23':
                    params['has_bands'] = True
                    params['has_spin_bands'] = True
                
        elif line == 'plot1d':
            nvcs, npts = (int(x) for x in lines[iline+1].strip().split())
            vcs = np.zeros((nvcs,3))
            for iv in range(nvcs):
                vcs[iv,:] = [float(x) for x in lines[iline+2+iv].strip().split()[0:3]]                

            params['plot1d']['nvcs'] = nvcs
            params['plot1d']['npts'] = npts
            params['plot1d']['vcs'] = vcs

        elif line == 'spinpol':
            flag = lines[iline+1].strip().split()[0]
            if flag == 'True' or flag == 'true':
                params['spinpol'] = True

        elif line == 'spinorb':
            flag = lines[iline+1].strip().split()[0]
            if flag == 'True' or flag == 'true':
                params['spinorb'] = True

        elif line == 'plot1d':
            nvcs, npts = (int(x) for x in lines[iline+1].strip().split())
            vcs = np.zeros((nvcs,3))
            for iv in range(nvcs):
                vcs[iv,:] = [float(x) for x in lines[iline+2+iv].strip().split()[0:3]]                
                params['plot1d']['nvcs'] = nvcs
                params['plot1d']['npts'] = npts
                params['plot1d']['vcs'] = vcs
            
    f.close() 

    return params


def plotpt1d(structure, npt, vv):
# npt  : number of connecting points (in,integer)
# vv   : vertex vectors in lattice coordinates (in,real(nv,3))

    cvec = structure.lattice.reciprocal_lattice.matrix
    nv = vv.shape[0]

    mat = structure.lattice.reciprocal_lattice.matrix
    vv_cart = np.array([np.dot(vec,mat) for vec in vv])

    if nv < 1:
        error_msg = "Error(plotpt1d): nv < 1 " + str(nv)
        raise IOError(error_msg)

    if npt < nv:
        error_msg = "Error(plotpt1d): npt < nv : " + str(npt) + " " + str(nv)

    dv = np.zeros(nv)
    dp = np.zeros(npt)
    vpl = np.zeros((npt,3))
    vpi = np.zeros(nv).astype(int)
    seg = np.zeros(nv)
    
    if nv == 1:
        dv[0] = 0.
        dp[:] = 0.
        for i in range(npt):
            vpl[i,:] = vv[0,:]
        
        return vpl, vpi

    # find the length of each segment and total distance
    dt = 0.
    for i in range(nv-1):
        dv[i] = dt
        vc = vv_cart[i+1,:]-vv_cart[i,:]
        seg[i] = np.linalg.norm(vc)
        dt = dt + seg[i]  
    dv[nv-1] = dt

    # add small amount to total distance to avoid 0/0 condition
    dt = dt + 1.e-8
    # number of points to use between vertices
    n = npt-nv

    # construct the interpolating path
    k = 0
    for i in range(nv-1):
        t1 = float(n)*seg[i]/dt
        m = int(np.rint(t1))
        vpi[i+1] = vpi[i] + m + 1        
 
        if m > n-1 or i == nv-1:
            m = n
        for j in range(m+1):
            f = float(j)/float(m+1)
            dp[k] = dv[i]+f*seg[i]
            vpl[k,:] = vv[i,:]*(1.-f)+vv[i+1,:]*f
            k += 1
        
        dt = dt - seg[i]
        n = n - m

    dp[npt-1] = dv[nv-1]
    vpl[npt-1,:] = vv[nv-1,:]
    
    return vpl, vpi



def get_bands_from_file(bands_file):
    """
    Reads energies from file of type BAND_SXX.OUT and BAND_SXX_AXXXX.OUT
    Returns the bands energies as an array of shape (nbands,nkpts). 
    """

    # Parse the band file
    try:
       f = open(bands_file,'r')
    except:
       error_msg = 'File '+bands_file+' not found!'
       raise IOError(error_msg)

    bands = []
    eband = []
    for line in f.readlines():
        line = line.strip()

        if line == '':
            bands.append(eband)
            eband = []             
        else:
            ee = float(line.split()[1])*Elkrun.hartree2ev 
            eband.append(ee)

    f.close()

    return np.array(bands)

def get_projected_bands_from_file(projs_file):
    """
    Reads angular projections from file of type BAND_SXX_AXXXX.OUT
    Returns the bands projections as an array of shape (nbands,nkpts,5).
    The sequence of projections is [total, s, p, d, f].
    """

    # Parse the band file
    try:
       f = open(projs_file,'r')
    except:
       error_msg = 'File '+projs_file+' not found!'
       raise IOError(error_msg)

    projs = []
    kprojs = []
    for line in f.readlines():
        line = line.strip()

        if line == '':
            projs.append(kprojs)
            kprojs = []             
        else:
            spdf = [float(x) for x in line.split()[2:]]
            #print 'spdf :', spdf
            kprojs.append(spdf)

    f.close()

    return np.array(projs)

def get_wfpwc_from_file(wfpw_file):
    """
    Reads the wavefunction plane-wave expansion coefficients from 
    formatted WFPW_FORM.OUT file. 
    Returns a disctionary with the plane-wave expansion coefficients
    """

    # Parse the band file
    try:
       f = open(wfpw_file,'r')
    except:
       error_msg = 'File '+wfpw_file+' not found!'
       raise IOError(error_msg)

    head = f.readline().strip()
    nkpt, npwc, nspinor, nbands = (int(x) for x in head.split())
    
    print (nkpt, npwc, nspinor, nbands)

    wfpwc = {}
    for ik in range(nkpt):
       wfpwc[ik] = {}
       for ib in range(nbands):
          pwc = np.zeros((npwc,nspinor), dtype=np.complex64)
          #wfpwc[ik][ib] = np.zeros((npwc,nspinor), dtype=np.complex64)
          for ispin in range(nspinor):
             jk, jb, js = (int(x) for x in f.readline().strip().split())
             h = [float(x) for x in f.readline().strip().split()]
             pwc[:,ispin] = np.array([complex(h[i],h[i+1]) for i in range(0,2*npwc,2)])	
          wfpwc[ik][jb-1] = pwc

    return wfpwc

             
 
def get_wfspin_from_file(wfspin_file):
    """
    Reads the wavefunction plane-wave expansion coefficients from 
    formatted WFPW_FORM.OUT file. 
    Returns a disctionary with the plane-wave expansion coefficients
    """

    # Parse the band file
    try:
       f = open(wfspin_file,'r')
    except:
       error_msg = 'File '+wfspin_file+' not found!'
       raise IOError(error_msg)

    head = f.readline().strip()
    nkpt, nspinor, nbands = (int(x) for x in head.split())
    
    print (nkpt, nspinor, nbands)

    wfspins = {}
    for ik in range(nkpt):
       wfspins[ik] = {}
       for ib in range(nbands):
          dts = f.readline().strip().split()
          jk, jb = (int(x) for x in dts[:2])
          sx, sy, sz = (float(x) for x in dts[2:])
          wfspins[ik][jb-1] = np.array([sx, sy, sz])

    return wfspins

             
