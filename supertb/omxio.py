""" 
Python Class dedicated to parse the file generated by Elk
"""

import os
import sys
import time
import numpy as np
import math
import warnings
import os.path

from supertb import Structure, Spinor, Eigenset

################################################################################  

class Omxrun(object):

    bohr2angstrom = 0.529177249
    hartree2ev = 27.211396132

    def __init__(self, fileroot="./", sys="system", name="System"):

        self.fileroot = fileroot
        self.sysname = sys
        self.filename = name

        # Parse the name.dat file
        self.set_params()

        # Parse the sys.md file
        self.set_geometry()

        # Parse the BANDDAT file
        self.set_eigenvalues()

        # Parse the sys.out file for molecular orbital coefficients
        self.set_eigenvectors()

    def set_params(self):

        infile = self.fileroot+self.filename+".dat"
        try:
           f = open(infile,'rb')
        except:
           error_msg = 'File '+infile+' not found!'
           raise IOError(error_msg)

        lines = f.readlines()   
        f.close()

        # Spin polarization
        spinpol = False
        spinorb = False
        for line in lines:
            if line.strip().lower().startswith('scf.spinpolarization'):
            #if 'scf.spinpolarization' in line.strip().lower():
                if line.strip().lower().split()[1] == 'on':
                    spinpol = True
                elif line.strip().lower().split()[1] == 'nc':
                    spinpol = True
                    spinorb = True
                break

        self.spin = Spinor(spinpol=spinpol, spinorb=spinorb)

        # Molecular orbitals
        self.has_mo = False
        for line in lines:
            if 'mo.fileout' in line.strip().lower():
                if line.strip().lower().split()[1] == 'off':
                    self.has_mo = False
                else:
                    self.has_mo = True
                break

        if self.has_mo:
            nkpoint = 0
            for line in lines:
                if 'mo.nkpoint' in line.strip().lower():
                    nkpoint = int(line.strip().lower().split()[1])
                    break

            if nkpoint > 0:
                for iline, line in enumerate(lines):
                    if 'mo.kpoint' in line.strip().lower():
                        self.mo_kpts = np.zeros((nkpoint,3))
                        for ik in range(nkpoint):
                            ldat = lines[iline+1+ik].strip().split()
                            self.mo_kpts[ik,:] = np.array([float(x) for x in ldat[:3]])
                        break

    
        # Band structure
        for line in lines:
            if 'band.dispersion' in line.strip().lower():
                if line.strip().lower().split()[1] == 'off':
                    self.has_bands = False
                else:
                    self.has_bands = True
                break

        if self.has_bands:
            for line in lines:
                if 'band.nkpath' in line.strip().lower():
                    nbranch = int(line.strip().lower().split()[1])
                    self.bands_path = np.zeros((2*nbranch,3))

            self.bands_vertices = [0] 
            kpts = []
            for iline, line in enumerate(lines):
                if 'band.kpath' in line.strip().lower():
                    for jl in range(nbranch):
                        ldat = lines[iline+1+jl].strip().split()
                        kstart = np.array([float(x) for x in ldat[1:4]])
                        kstop = np.array([float(x) for x in ldat[4:7]])
                        nkpts = int(ldat[0])
          
                        for ikpt in range(nkpts):
                            kpt = kstart + ikpt*(kstop-kstart)/(float(nkpts)-1)          
                            #print '{:12.9f}  {:12.9f}  {:12.9f}'.format(*kpt)
                            kpts.append(kpt)

                        self.bands_path[2*jl] = kstart
                        self.bands_path[2*jl+1] = kstop
                        
                        self.bands_vertices.append(len(kpts)-1)
                    break
            
            self.kpts = np.array(kpts)
            #self.wkpts = np.array([1.]*len(self.kpts))/len(self.kpts)
            self.wkpts = np.array([1.]*len(self.kpts))

            for iv in self.bands_vertices:
                if iv+1 < len(self.wkpts) and iv > 0:
                    self.wkpts[iv+1] = 0.

    def set_geometry(self):

        geomfile = self.fileroot+self.sysname+".md"
        try:
           f = open(geomfile,'rb')
        except:
           error_msg = 'File '+geomfile+' not found!'
           raise IOError(error_msg)

        lines = f.readlines()   
        f.close()

        natom = int(lines[0].strip().split()[0])
        cell = np.array([float(x) for x in lines[1].strip().split()[7:16]]).reshape((3,3))
        #print cell
        attypes = []
        atpos = []
        for il in range(2,natom+2):
            attypes.append(lines[il].strip().split()[0])
            pos = np.array([float(x) for x in lines[il].strip().split()[1:4]])
            atpos.append(pos)

        self.structure = Structure(cell,attypes,atpos,coords_are_cartesian=True)


    def set_band_eigenvalues(self):
        
        self.bands_structure = Eigenset(self.structure.lattice, spin=self.spin, \
                               kpts=self.kpts, wkpts=self.wkpts, fractional=True, \
                               vertices=self.bands_vertices)

        bandfile = self.fileroot+self.sysname+".Band"
        try:
            f = open(bandfile,'rb')
            f.close()
        except:
            error_msg = 'File '+bandfile+' not found!'
            raise IOError(error_msg)
         


    def set_eigenvalues(self):

        self.bands_structure = Eigenset(self.structure.lattice, spin=self.spin, \
                               kpts=self.kpts, wkpts=self.wkpts, fractional=True, \
                               vertices=self.bands_vertices)

        nkpts = len(self.kpts)
        for ispin in range(self.spin.nspin):
            jspin = ispin + 1
            bandfile = self.fileroot+self.sysname+".BANDDAT"+str(jspin)
            try:
               f = open(bandfile,'rb')
               f.close()
            except:
               error_msg = 'File '+bandfile+' not found!'
               raise IOError(error_msg)

            #lines = f.readlines()   
            #f.close()

            with open(bandfile) as infile:
                ib = -1
                ik = -1
                #for line in lines:
                for line in infile:
                    if line.strip() != '':
                        if float(line.strip().split()[0]) == 0. and \
                           (ik==-1 or ik==nkpts-1):
                            ib += 1  
                            #print ib, ik
                            ik = -1              
                        if ib >= 0:
                            ik += 1
                            ee = float(line.strip().split()[1])
                            self.bands_structure.set_eigenvalue(ik, ib, ispin, E=ee)

            self.nbands = ib + 1
            self.nbasis = self.nbands/self.spin.nbasis 

    def set_eigenvectors(self):

        if not self.has_mo:
            return

        self.eigenvectors = Eigenset(self.structure.lattice, spin=self.spin, \
                                     kpts=self.mo_kpts, fractional=True)

        bandfile = self.fileroot+self.sysname+".out"
        try:
           f = open(bandfile,'rb')
        except:
           error_msg = 'File '+bandfile+' not found!'
           raise IOError(error_msg)

        lines = f.readlines()   
        f.close()

        for il in range(len(lines)):
            if 'LCAO coefficients' in lines[il]:
                lstart = il+6
                break

        lp = lstart

        for ispin in range(self.spin.nspin):
            for ik in range(len(self.mo_kpts)):
            
                #print lines[lp]
                lp += 9

                nb_tot = 0
                while nb_tot < self.nbands:
            
                    #print lines[lp]
                    ibands = [int(x) for x in lines[lp].strip().split()]   
                    nb = len(ibands)
                    ebands = [float(x) for x in lines[lp+1].strip().split()]
                    lp += 5
                    
                    eigv = np.zeros((nb, self.nbasis*self.spin.nbasis),dtype=complex)
                    for ibasis in range(self.nbasis):
                    
                        #print ibasis, lines[lp].strip()
                        data = [float(x) for x in lines[lp].strip().split()[-2*nb*self.spin.nbasis:]]
                        eptr = 0
                        for ib in range(nb):
                            for ispinbasis in range(self.spin.nbasis):
                                eigv[ib,ibasis+ispinbasis*self.nbasis] = data[eptr] + 1j*data[eptr+1]
                                eptr += 2
                        lp += 1
           
                    for ib in range(nb):
                        self.eigenvectors.set_eigenvalue(ik, ibands[ib]-1, ispin, E=ebands[ib], V=eigv[ib,:])
           
                    nb_tot += nb
                    lp += 1 

                lp += 1 



 

################################################################################  



