""" 
Python Class dedicated to parse the files generated by Elk
"""


import os
import sys
import time
import numpy as np
import math
import warnings
import os.path
import itertools

from supertb import Structure, Lattice, Spinor, Eigenset, PeriodicPointCollection
import itertools
import pymatgen.io.vasp as pmio

################################################################################  

class Vaspref():


    def __init__(self, verbose=False, fileroot="./", parse_projected_eigen=False):
      
        self.fileroot = fileroot
 
        # Parse the INCAR file
        self.set_params(verbose=verbose)

        # Parse the POSCAR file
        self.set_geometry()

        # Parse eigenvalues from Eigenval file
        if os.path.isfile(self.fileroot+'EIGENVAL') and not parse_projected_eigen:
            self.set_eigenvalues_from_eigenval()

        # Parse the eigenvalues in vasprun.xml file
        else:
            self.set_eigenvalues(verbose=verbose, parse_projected_eigen=parse_projected_eigen)

    def set_params(self, verbose=False):

        incar_file = self.fileroot+'INCAR'
        incar = pmio.inputs.Incar.from_file(self.fileroot+'INCAR')

        spinpol = False
        spinorb = False
        if 'ISPIN' in incar:
            if incar['ISPIN'] == 1:
                spinpol = False
            else:
                spinpol = True
        if 'LNONCOLLINEAR' in incar:
            if incar['LNONCOLLINEAR']:
                spinorb = True
            else:
                spinorb = False
        elif 'LSORBIT' in incar:
            if incar['LSORBIT']:
                spinorb = True
            else:
                spinorb = False
        else:
            spinorb = False
        self.spin = Spinor(spinpol=spinpol, spinorb=spinorb)

        self.has_projections = False
        if 'LORBIT' in incar:
            if incar['LORBIT']:
                self.has_projections = True
            else:
                self.has_projections = False

        if verbose:
            print (' ...spinpol ', self.spin.spinpol)
            print (' ...spinorb ', self.spin.spinorb)
            print (' ...projections ', self.has_projections)

    def set_geometry(self):

        geom_file = self.fileroot+'POSCAR'
        poscar = pmio.inputs.Poscar.from_file(geom_file, check_for_POTCAR=False, read_velocities=False)
        self.structure = poscar.structure

    def set_eigenvalues_from_eigenval(self):
        eigenval = pmio.outputs.Eigenval(self.fileroot+'EIGENVAL')
        self.kpts = np.array(eigenval.kpoints)
        vasprun = pmio.outputs.Vasprun(self.fileroot+'vasprun.xml', parse_projected_eigen=False)
        self.efermi = vasprun.efermi
        
        kpoints = pmio.inputs.Kpoints.from_file(self.fileroot+'KPOINTS')
        #if kpoints.style == pmio.inputs.Kpoints_supported_modes(3):
        if kpoints.style == pmio.inputs.KpointsSupportedModes(3):
            self.bands_path = kpoints.kpts
            nl = int(len(kpoints.kpts)/2)
            nk = kpoints.num_kpts
            bands_vertices = np.array([0]+[(il*nk)-1 for il in range(1,nl+1)])
            self.wkpts = np.array([1.]*len(self.kpts))
        
            self.bands_structure = Eigenset(self.structure.lattice, spin=self.spin, \
                                   kpts=self.kpts, wkpts=self.wkpts, fractional=True, \
                                   vertices=bands_vertices)
        
            for ispin, spin in enumerate(eigenval.eigenvalues):
                for ik, eigk in enumerate(eigenval.eigenvalues[spin]):
                    for ib, eigb in enumerate(eigk):
                        self.bands_structure.set_eigenvalue(ik, ib, ispin, E=eigb[0])

        else:
            self.wkpts = np.array(eigenval.kpoints_weights)
            self.eigenvalues = Eigenset(self.structure.lattice, spin=self.spin,\
                               kpts=self.kpts, wkpts=self.wkpts, fractional=True)

            for ispin, spin in enumerate(eigenval.eigenvalues):
                for ik, eigk in enumerate(eigenval.eigenvalues[spin]):
                    for ib, eigb in enumerate(eigk):
                        self.eigenvalues.set_eigenvalue(ik, ib, ispin, E=eigb[0])

    def set_eigenvalues(self, verbose=False, parse_projected_eigen=True):

        kpoints = pmio.inputs.Kpoints.from_file(self.fileroot+'KPOINTS')
        if self.has_projections:
            vasprun = pmio.outputs.Vasprun(self.fileroot+'vasprun.xml', parse_projected_eigen=True)
        else:
            vasprun = pmio.outputs.Vasprun(self.fileroot+'vasprun.xml', parse_projected_eigen=False)
        self.efermi = vasprun.efermi
        self.kpts = vasprun.actual_kpoints

        if verbose:
            print ('...read ', self.fileroot+'KPOINTS')
            print ('...nkpts ', len(self.kpts))
            print ('...efermi ', self.efermi) 
         

        if kpoints.style == pmio.inputs.Kpoints_supported_modes(3):
            self.bands_path = kpoints.kpts
            nl = int(len(kpoints.kpts)/2)
            nk = kpoints.num_kpts
            bands_vertices = np.array([0]+[(il*nk)-1 for il in range(1,nl+1)])
            self.wkpts = np.array([1.]*len(self.kpts))
        
            self.bands_structure = Eigenset(self.structure.lattice, spin=self.spin, \
                                   kpts=self.kpts, wkpts=self.wkpts, fractional=True, \
                                   vertices=bands_vertices)
           
            if self.has_projections:
                for ispin, spin in enumerate(vasprun.eigenvalues):
                    for ik, eigk in enumerate(vasprun.eigenvalues[spin]):
                        for ib, eigb in enumerate(eigk):
                            proj = vasprun.projected_eigenvalues[spin][ik][ib]
                            #print ('---')
                            #print (ispin, spin, ik, ib, eigb)
                            norm = np.reshape(np.sum(proj,axis=-1),(proj.shape[0],1))
                            #print (norm.shape)
                            #print (norm)
                            #print (proj.shape)
                            #print (proj)
                            #if ib == 1:
                            #   break
                            self.bands_structure.set_eigenvalue(ik, ib, ispin, E=eigb[0]-self.efermi)
                            self.bands_structure.set_eigenvalue(ik, ib, ispin, P=np.concatenate((norm,proj),axis=1))
                        #if ik == 1:
                        #    break
            else:
                for ispin, spin in enumerate(vasprun.eigenvalues):
                    for ik, eigk in enumerate(vasprun.eigenvalues[spin]):
                        for ib, eigb in enumerate(eigk):
                            self.bands_structure.set_eigenvalue(ik, ib, ispin, E=eigb[0]-self.efermi)


        else:
            self.wkpts = np.array(vasprun.actual_kpoints_weights)
            self.eigenvalues = Eigenset(self.structure.lattice, spin=self.spin,\
                               kpts=self.kpts, wkpts=self.wkpts, fractional=True)

            if self.has_projections:
                for ispin, spin in enumerate(vasprun.eigenvalues):
                    for ik, eigk in enumerate(vasprun.eigenvalues[spin]):
                        for ib, eigb in enumerate(eigk):
                            proj = vasprun.projected_eigenvalues[spin][ik][ib]
                            #print ('---')
                            #print (ispin, spin, ik, ib, eigb)
                            norm = np.reshape(np.sum(proj,axis=-1),(proj.shape[0],1))
                            #print (norm.shape)
                            #print (norm)
                            #print (proj.shape)
                            #print (proj)
                            #if ib == 1:
                            #   break
                            self.eigenvalues.set_eigenvalue(ik, ib, ispin, E=eigb[0]-self.efermi)
                            self.eigenvalues.set_eigenvalue(ik, ib, ispin, P=np.concatenate((norm,proj),axis=1))
                        #if ik == 1:
                        #    break
            else:
                for ispin, spin in enumerate(vasprun.eigenvalues):
                    for ik, eigk in enumerate(vasprun.eigenvalues[spin]):
                        for ib, eigb in enumerate(eigk):
                            self.eigenvalues.set_eigenvalue(ik, ib, ispin, E=eigb[0]-self.efermi)


class Wavecar(object):

    # Constant (2m/hbar**2) adjusted to agree with VASP value.
    #cc = 0.262465831
    cc = 0.26246582250210965422  

    def __init__(self,file=None, verbose=False):
  
        # By default, look for file "vasprun.xml"
        if file is None:
            self.filename = "WAVECAR"
        else:
            self.filename = file
     
        try:
           f = open(self.filename,'rb')
        except:
           raise IOError("File not found") 
      
        # Read basic infos from first records
        # ireclw = icmplx*max(nlwv,6)
        # rtag = {'53300', '53310', '45200', ....} 
        self.ireclw, self.nspin, self.rtag = np.fromfile(f,dtype=np.float64,count=3).astype(int)
        if verbose:
            print ("ireclw = ", self.ireclw)
            print ("nspin = ", self.nspin)
            print ("rtag = ", self.rtag)
       
        # Rewind file and estimate record length
        f.seek(0,0)
        if self.rtag == 45200:
            div = 8
        else: 
            div = 2
        buf1 = np.fromfile(f,dtype=np.float64,count=int(self.ireclw/div))
        self.recl = f.tell()
       
        # Read bands and cell infos from second record
        self.nkpt, self.nband = np.fromfile(f,dtype=np.float64,count=2).astype(int)
        self.ecut = np.fromfile(f,dtype=np.float64,count=1)[0]
        self.lattice = Lattice(np.fromfile(f,dtype=np.float64,count=9).reshape((3,3)))
        self.rlattice = self.lattice.reciprocal_lattice
        if verbose:
            print ("nkpt  = ", self.nkpt)
            print ("nband = ", self.nband)
            print ("ecut  = ", self.ecut)
            print ("Lattice...")
            print (self.lattice)
       
        # Etimate the size of the reciprocal grid
        # and the maximum number of plane-waves.
        self.ngmax = np.array([(self.ecut*Wavecar.cc)**0.5/np.linalg.norm(vv) \
                     for vv in self.rlattice.matrix]).astype(int) + 1
        self.npmax = (self.ngmax*2+1).prod()
        if verbose:
            print ("ngmax = ", self.ngmax)
        #print "npmax = ", self.npmax
       
        # Allocate object numpy variables
        self.npw = np.empty(self.nkpt).astype(int)
        self.kpt = np.empty((self.nkpt,3))
        self.occ = np.empty((self.nkpt,self.nband,self.nspin))
        #self.ener = np.empty((self.nkpt,self.nband,self.nspin)).astype(np.cfloat)
        self.ener = np.empty((self.nkpt,self.nband,self.nspin)).astype(complex)
       
        # Read band-structure
        irec = 1
        #irec = 2
        for ispin in range(self.nspin):
            for ikpt in range(self.nkpt):
                irec = irec + 1
                f.seek(irec*self.recl,0)
                self.npw[ikpt] = np.fromfile(f,dtype=np.float64,count=1)
                #print (' ikpt: ', ikpt, ' npw: ', self.npw[ikpt])
                self.kpt[ikpt] = np.fromfile(f,dtype=np.float64,count=3)
                #print (' kpt: ', self.kpt[ikpt])
                buffer = np.fromfile(f,dtype=np.float64,count=3*self.nband)
                self.ener[ikpt,:,ispin] = [(buffer[ix*3]+1j*buffer[ix*3+1]) for ix in range(self.nband)]
                self.occ[ikpt,:,ispin] = [buffer[ix*3+2] for ix in range(self.nband)]

                #print "spin = ", ispin, "- ikpt = ", ikpt, "- kpt = ", self.kpt[ikpt], "- npw = ", self.npw[ikpt], " - e = ", self.ener[ikpt,:3,ispin]
             
                irec = irec + self.nband

        # Close file
        f.close()

    def check_reciprocal_grid(self):

        #print 'check reciprocal grid!'
        # Build full set of G vectors
        if not hasattr(self,'ggrid'): 

            viter = [list(range(self.ngmax[0]+1))+list(range(-self.ngmax[0],0)),\
                     list(range(self.ngmax[1]+1))+list(range(-self.ngmax[1],0)),\
                     list(range(self.ngmax[2]+1))+list(range(-self.ngmax[2],0))]

            npts = np.product([len(i) for i in viter])
            gpts = np.empty([npts,3])
            ptr = 0
            for x in itertools.product(*[viter[-i] for i in range(1,len(viter)+1)]):
                gpts[ptr,:] = [x[-i] for i in range(1,len(x)+1)]
                ptr += 1

            #print self.ngmax
            #print gpts

            self.ggrid = PeriodicPointCollection(self.rlattice.matrix,coords=gpts,cartesian=False)
            #print self.ggrid.lattice
            #print self.ggrid.size

            # Create subsets associated with each k-point
            for ikpt in range(self.nkpt):
                
                kpt = self.ggrid.lattice.get_cartesian_coords(self.kpt[ikpt])
                #print ikpt, kpt
                ekin = np.sum((self.ggrid.coords + kpt)**2,axis=-1)/Wavecar.cc
 
                ipw=[]
                for ii in range(len(ekin)):
                    if ekin[ii] < self.ecut:
                        ipw.append(ii)
           
                #print len(ekin), len(ipw) 
                self.ggrid.create_subset(ikpt, ipw)

#    @property
    def colinear(self):
       
        if not hasattr(self,'_colinear'):
            
            #print ('colinear attribute undefined...',self.ngmax, self.ecut) 
            ncoef = 0
            for kg, jg, ig in itertools.product( \
                     list(range(self.ngmax[2]+3))+list(range(-self.ngmax[2]-2,0)),\
                     list(range(self.ngmax[1]+3))+list(range(-self.ngmax[1]-2,0)),\
                     list(range(self.ngmax[0]+3))+list(range(-self.ngmax[0]-2,0))):
                gv = [ig,jg,kg]
                etot = np.sum(self.rlattice.get_cartesian_coords(self.kpt[0]+gv)**2)/Wavecar.cc
                if (etot < self.ecut):
                   ncoef = ncoef + 1
            
            if (2*ncoef == self.npw[0]):
                self._colinear = False
            else:
                self._colinear = True


            print (self.kpt[0])
            print (ncoef, self.npw[0])
 
        return self._colinear 


    @property
    def reciprocal_grid(self):

        self.check_reciprocal_grid()
        return self.ggrid

    def plane_waves_coefficients(self,ikpt,iband,ispin):

        # Open wave file
        try:
           f = open(self.filename,'rb')
        except:
           raise IOError("File not found") 

        # Look for the record corresponding to the appropriate k-point
        irec = 2 + ispin*self.nkpt*(self.nband+1) + ikpt*(self.nband+1)
        f.seek(irec*self.recl,0)

        # Read number of plane-waves for verification
        npw = np.fromfile(f,dtype=np.float64,count=1)
        if (int(npw) != self.npw[ikpt]):
            raise RuntimeError("Number of plane-waves in selected record is incorrect")

        # Read plane-waves
        irec = irec + iband + 1
        f.seek(irec*self.recl,0)

        coeff = np.fromfile(f,dtype=np.complex64,count=self.npw[ikpt])
        f.close()

        if not self._colinear:

            spinpw = int(self.npw[ikpt]/2)
            spinor = np.zeros((spinpw,2),dtype=np.complex64)
            spinor[:,0] = coeff[:spinpw]
            spinor[:,1] = coeff[spinpw:]
            return spinor
            #coe = coeff.reshape([2,int(self.npw[ikpt]/2)]).T

        else:
            return coeff

    def evaluate(self,ikpt,iband,ispin,coords,cartesian = True,normalized=True):

        pw_vecs = self.reciprocal_grid.subset_frac_coords(ikpt) + self.kpt[ikpt]
        pw_coefs = self.plane_waves_coefficients(ikpt,iband,ispin)

        if cartesian:
            frac_coords = self.lattice.get_fractional_coords(coords)
        else:
            frac_coords = coords

        #wv = np.dot(pw_coefs,np.exp(2.*np.pi*1j*np.dot(pw_vecs,frac_coords.T)))
        twopij = 2.*np.pi*1j

        print (pw_vecs.shape, frac_coords.shape)        
        kr = np.dot(pw_vecs,frac_coords.T)

        print (kr.shape)
        ekr = np.exp(twopij*kr)

        print (pw_coefs.shape, ekr.shape)
        wv = np.dot(pw_coefs.T,ekr)
 
        if normalized:
            #norm = np.sqrt(np.sum(wv*np.conj(wv)))
            norm = np.linalg.norm(wv)
            return wv.T/norm
        else:
            return wv.T
 
################################################################################ 

